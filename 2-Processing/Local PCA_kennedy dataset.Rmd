---
title: "Local PCA_Kennedy Dataset"
author: "Athmaja Viswanath"
date: "2025-08-05"
output:
  html_document:
    df_print: paged
---
Section naming convention 0_A_I
#0. Loading Packages
```{r}
library(lostruct)
library(vcfR)
library(tidyverse)
library(plotly)
library(stats)
library(dplyr)
library(reshape2)
library(ggplot2)
library(RColorBrewer)

```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#1.Preprocessing Vcf File
##A. Reading in the VCF file and filtering SNPs 
```{r}
#1. reading in VCF file
getwd()#making sure that trhe working directory is correct
vcf_chr17 = read.vcfR("../1-Input/chr17.vcf", verbose = FALSE)

# Get sample names
sample_names <- colnames(vcf_chr17@gt)[-1]  # Remove the "FORMAT" column
print(sample_names)

```

##B. Re-writing the vcf_positions function from lostruct that uses bcftools 
```{r}
# Extract chromosome and position
chroms <- getCHROM(vcf_chr17)
positions <- getPOS(vcf_chr17)

# Create a named list like `vcf_positions()`, name - chromosome, within whcih is the position , this output a list
vcf_pos_list <- split(positions, chroms)
```

##C. Extracting and recoding genotype matrix

```{r}
#Extracting genotype matrix
gt_matrix_17 <- extract.gt(vcf_chr17, element = "GT", as.numeric = FALSE)
head(gt_matrix_17)

#Recoding genotype matrix to indicate 
# 0/0 - homozygous ref - 0
# 0/1 or 1/0 - heterozygous - 1
# 1/1 - homozygous alt - 2

#0/0 is unphased while 0|0 is phased data 

gt_recode <- apply(gt_matrix_17, 2, function(x) {
  x <- gsub("0\\|0|0/0", "0", x) 
  x <- gsub("0\\|1|1\\|0|0/1|1/0", "1", x)
  x <- gsub("1\\|1|1/1", "2", x)
  x[x %in% c(".", "./.", ".|.")] <- NA
  return(as.numeric(x))
}) 

#,making sure the extracted matrix is numeric
gt_numeric_allsamples_num <- matrix(
  as.numeric(gt_recode),
  nrow = nrow(gt_matrix_17),
  ncol = ncol(gt_matrix_17)
)

#Adding the correct column names
colnames(gt_numeric_allsamples_num) <- colnames(gt_matrix_17)


#filter VCF file NOTE IF I DO THIS, BROAD RESUTLS OK, BUT SPECIFIC POPULATIOSN ARE NOT ACCURATE
# missing_rate <- colMeans(is.na(gt_numeric_allsamples_num))
# gt_numeric_allsamples_num <- gt_numeric_allsamples_num[, missing_rate < 0.2]
```

#2. Sliding Windows Creation (Rewriting vcf_windower with vcfR)
Creating sliding windows for the genotype matrix and saving each window as a list of matrices, while also making sure that we have chrom, star, end data for each window. 
The original vcf_windower function creates sliding windows of SNPs by position for each chromosome.
Basic Concept:
For each chromosome:
Take the POS (position) vector.
Make overlapping or non-overlapping windows of SNPs based on a fixed window size or base-pair distance.
Store them as a list of data.frames with chrom, start, end.
##A. Custom function to create slidign windows for a given genotype matrix

```{r}


make_vcf_windows <- function(vcf_obj, window_size = 100, step_size = 50, min_snps = 10) {
  chroms <- getCHROM(vcf_obj)
  positions <- getPOS(vcf_obj)
  
  # Combine chrom and pos
  snp_df <- data.frame(chrom = chroms, pos = positions)
  windows_list <- list()
  
  for (chr in unique(snp_df$chrom)) {
    chr_pos <- snp_df[snp_df$chrom == chr, "pos"]
    n_snps <- length(chr_pos)
    
    i <- 1
    while (i + window_size - 1 <= n_snps) {
      pos_window <- chr_pos[i:(i + window_size - 1)]
      if (length(pos_window) >= min_snps) {
        windows_list[[length(windows_list) + 1]] <- data.frame(
          chrom = chr,
          start = min(pos_window),
          end = max(pos_window)
        )
      }
      i <- i + step_size
    }
  }
  
  windows_df <- do.call(rbind, windows_list)
  rownames(windows_df) <- NULL
  return(windows_df)
}

#using the function
regions <- make_vcf_windows(vcf_chr17, window_size = 1000, step_size = 500)
View(regions)
#gives a dataframe with chrom, start, end as columns that can be used to "map" windows on the genome

```

##B. Custom windows extractor function to be used for local pca input
This is especially useful is genotype matrix is too big or is split into chromosomes. this fucntion feed 1 window at a time to the perform local PCA.

```{r}
make_custom_winfun <- function(gt_matrix, regions, variant_chroms, variant_positions) {
  # Returns a function that extracts genotype matrix for window n
  winfun <- function(n) {
    if(any(n < 1 | n > nrow(regions))) stop("Window index out of range")
    region <- regions[n, ]
    # Find variants in this chrom and position range
    idx <- which(variant_chroms == region$chrom & 
                   variant_positions >= region$start & 
                   variant_positions <= region$end)
    if(length(idx) == 0) {
      warning(sprintf("Window %d has no variants.", n))
      return(NULL)  # or matrix(nrow=0, ncol=ncol(gt_matrix))
    }
    return( gt_matrix[idx, , drop=FALSE] )
  }
  attr(winfun, "max.n") <- nrow(regions)
  attr(winfun, "region") <- function(n) { regions[n, , drop=FALSE] }
  attr(winfun, "samples") <- colnames(gt_matrix)
  class(winfun) <- c("winfun", "function")
  return(winfun)
}


# Create the extractor function:
variant_chroms <- getCHROM(vcf_chr17)
variant_positions <- getPOS(vcf_chr17)
winfun <- make_custom_winfun(gt_numeric_allsamples_num, regions, variant_chroms, variant_positions)

#winfun is the final custom function that then will be used to run local pca 
```

#3. Running local PCA on each window from the list of matrices
eigen_windows - Subtracts row means from the input matrix, then divides the rows into windows of a given size, 
computes the covariance matrix for each, and returns for each window the total sum of squares and the given number
of eigenvector/eigenvalue pairs. Omits the last (short) window

```{r}
#computing eigenvectors for covaraince matrix 
eigen = eigen_windows(data = winfun, k = 2, win = NULL )   #uses eigen_windows() function from lostruct
dim(eigen)
head(eigen)
str(eigen)

#should output a table with rows as windows, columsn as PC1 and PC2/samples
```

Alternatively, for broad overview of patterns, we can directly give the genotype matrix as the input and eigen_windows can make contiguous windows for us using the "win" parameter - this will be coarse though
```{r}

# eigen_stuff_allsamples = eigen_windows(data = gt_numeric_allsamples_num, k = 2, win = 1000 ) #shoudl output a table with rows as windows, columsn as PC1 and PC2/samples
# dim(eigen_stuff_allsamples)
# head(eigen_stuff_allsamples)
```

#4. Calculate pairwise-distances bewteen windows
##A. Calculating distance between windows
pc_dist - You have a list of symmetric matrices stored as eigenvalues and eigenvectors. 
This function reconstructs 
each matrix approximately using those components, then compares every pair using the Frobenius norm 
(a measure of how different two matrices are). The result is an n x n matrix where entry [i, j] shows the difference between matrix i and matrix j.
```{r}
windist_allsamples <- pc_dist( eigen, npc=2 )  #uses pc_dist() function from lostruct
head(windist_allsamples)
```

##B. Running MDS 
```{r}
fit2d_allsamples <- cmdscale( windist_allsamples, eig=TRUE, k=2 )  #uses cmdscale() function from lostruct
plot( fit2d_allsamples$points, xlab="Coordinate 1", ylab="Coordinate 2", col=rainbow(1.2*nrow(windist_allsamples)) )


```

##C. Making a dataframe that combines MDS values for each window along with genomic information
```{r}
#Identifying and labeling corners
xy_coords <- fit2d_allsamples$points

# Ensure the number of rows match
stopifnot(nrow(xy_coords) == nrow(regions))

# Combine genomic and MDS coordinates
mds_df <- cbind(regions, 
                MDS1 = xy_coords[,1],
                MDS2 = xy_coords[,2])
mds_df$midpoint = (mds_df$start + mds_df$end)/2

```

##D. Identifying extreme values/outliers or "corners"

```{r}
# Get 3 "extreme" corners with top 5% of nearest points for each
corner_indices <- corners(xy_coords, prop = 0.05, k = 2) #uses corners() function from lostruct

# Label the extreme windows Flatten corner indices
extreme_idx <- unique(as.vector(corner_indices))
mds_df$corner_outlier <- FALSE
mds_df$corner_outlier[extreme_idx] <- TRUE

```

#5. Visualize the distance between each window and identifying potential Structural variant windows
##A. MDS Plots
This step helps identify extreme manifestations or "corners" as in a corner of a triangle that can then be used to aggregate and form a "combined window" in the next steps 
```{r}
##MDS PLOTS WITH OUTLIERS!
ggplot(mds_df, aes(x = midpoint, y = MDS1, color = corner_outlier)) +
  geom_point() +
  facet_wrap(~ chrom, scales = "free_x") +
  labs(title = "MDS1 vs Genomic Position",
       x = "Genomic Midpoint",
       y = "MDS1") +
  scale_color_manual(values = c("black", "red")) +
  theme_bw()

ggplot(mds_df, aes(x = MDS2, y = MDS1, color = corner_outlier)) +
  geom_point() +
  facet_wrap(~ chrom, scales = "free_x") +
  labs(title = "MDS1 vs MDS2",
       x = "MDS2",
       y = "MDS1") +
  scale_color_manual(values = c("black", "red")) +
  theme_bw()

```

##B. Extracting genotype data for each "corner window"
need to have the window-wise genomic location details so we can extract the specific matrix
```{r}
##GETTING CORNER DATA, FOR ALL CORNERS
corner.regions <- vector(mode='list', length=ncol(corner_indices))
for (k in seq_along(corner.regions)) {
  corner.regions[[k]] <- regions[ corner_indices[,k],]
}

corner.genotypes <- vector("list", length = length(corner.regions))
for (k in seq_along(corner.regions)) {
  reg <- corner.regions[[k]]
  keep_rows <- unlist(mapply(function(ch, start, end) {
    which(variant_chroms == ch & variant_positions >= start & variant_positions <= end)
  }, reg$chrom, reg$start, reg$end, SIMPLIFY = FALSE))
  
  corner.genotypes[[k]] <- gt_numeric_allsamples_num[keep_rows, , drop = FALSE]
}

#perform aggregate PCA on each "corner"

```

##C. Identifying interesting widnows using interactive plot
Alternatively, probably more useful, we can make an interactive ggplot using plotly to extract windows midpoints and use that to extract indices and get genotype data

```{r}
#creating the MDS1 vs Genomic location plot
p <- ggplot(mds_df, aes(x = midpoint, y = MDS1)) +
  geom_point() +
  facet_wrap(~chrom, scales = "free_x")

ggplotly(p) #better to run in console

#extract windows between extreme windows on the plot. From the plot, we can get midpoints
#For example left most window's midpoint = 6028409, right most window's midpoint = 40657059

#Extracting windows within extreme midpoints
cluster_idx <- which(mds_df$midpoint >= 6028409 & mds_df$midpoint <= 40657059)
cluster_windows <- mds_df[cluster_idx, ]

dim(cluster_windows)

```

##D. Extracting genotype matrix for interesting windows
```{r}
#Extracting genotype matrix for these windows
keep_rows <- unlist(mapply(function(ch, start, end) {
  which(variant_chroms == ch & variant_positions >= start & variant_positions <= end)
}, cluster_windows$chrom, cluster_windows$start, cluster_windows$end, SIMPLIFY = FALSE))

#Final genotype matrix that has all genotype information for only the region we are interested in
cluster_genotypes <- gt_numeric_allsamples_num[keep_rows, , drop = FALSE]
```

#6. Aggregate PCA for the interested region
##A. Processing genotype matrix data for PCA run

```{r}
#Preparong data
# Calculate variance for each SNP (row) across samples (columns)
# Remember your matrix is SNPs x samples, so variance per row
var_per_snp <- apply(cluster_genotypes, 1, var, na.rm = TRUE)

# Keep only SNPs with variance > 0
cluster_genotypes_var <- cluster_genotypes[var_per_snp > 0, , drop = FALSE]
cluster_genotypes_var = na.omit(cluster_genotypes_var)

```


##B. Run PCA and save data
```{r}
# Run PCA on filtered matrix (transpose to samples x SNPs)
pca_res <- prcomp(t(cluster_genotypes_var), center = TRUE, scale. = TRUE)

# Extract PCA scores (coordinates of samples)
pca_scores <- data.frame(pca_res$x)

# Add sample names as a column
pca_scores$sample <- colnames(cluster_genotypes_var)

# Add a new column called 'region' based on the Sample name
pca_scores$region <- dplyr::case_when(
  grepl("^IRA_", pca_scores$sample) ~ "Iran",
  grepl("^FRA_", pca_scores$sample) ~ "France",
  grepl("^GER_", pca_scores$sample) ~ "Germany",
  grepl("^MWN01[A-H]", pca_scores$sample) ~ "Northeast Spain",
  grepl("^MWN01[I-P]", pca_scores$sample) ~ "Italy",
  grepl("^MWN01Q|^MWN01R|^MWN03-I_|^MWN03-M_|^MWN03-P_", pca_scores$sample) ~ "England",
  grepl("^MWN01S|^MWN01T|^MWN01U|^MWN01V|^MWN01W|^MWN01X|^MWN03-G_|^MWN03-H_|^MWN03-J_|^MWN03-N_|^MWN03-Q_", pca_scores$sample) ~ "Scotland",
  grepl("^MWN02[A-J]", pca_scores$sample) ~ "Portugal",
  grepl("^MWN02[K-T]", pca_scores$sample) ~ "Southwest Spain",
  grepl("^MWN03-[A-E]", pca_scores$sample) ~ "North France",
  grepl("^MWN03-F_", pca_scores$sample) ~ "Guernsey",
  grepl("^MWN03-K_", pca_scores$sample) ~ "Wales",
  TRUE ~ "Unknown"
)

# PCA results
head(pca_scores, 10)
```

#7. Visualize PC1 vs PC2 plots
##A. PC1 vs PC2 plots - basic, by sample, by region
```{r}
#Basic PCA plot
ggplot(pca_scores, aes(x = PC1, y = PC2)) +
  geom_point(size = 3) +
  theme_minimal() +
  labs(title = "PCA: PC1 vs PC2",
       x = "PC1",
       y = "PC2") +
  theme(legend.position = "right")


# Plot PC1 vs PC2 colored by sample
ggplot(pca_scores, aes(x = PC1, y = PC2, color = sample)) +
  geom_point(size = 3) +
  theme_minimal() +
  labs(title = "PCA: PC1 vs PC2",
       x = "PC1",
       y = "PC2") +
  theme(legend.position = "right")

# Coloured by region
ggplot(pca_scores, aes(x = PC1, y = PC2, fill = region)) +
  geom_point(size = 3, shape = 21, colour = "black") +
  theme_minimal() +
  labs(title = "PCA: PC1 vs PC2",
       x = "PC1",
       y = "PC2") +
  geom_text(aes(label = region), vjust = -0.5, hjust = 0.5)+
  theme(legend.position = "right")+
  scale_color_brewer(palette = "Set3") 

```

##B. Visualizing clusters usign K-means clustering
###I. Looking at 2 clusters
```{r}
#Creating clusters
km_2 <- kmeans(pca_scores[, c("PC1", "PC2")], centers = 2)  # or 3
pca_scores$cluster <- factor(km_2$cluster)
pca_scores_cl2 = pca_scores 

#Plotting 2 clusters on PCA plot
ggplot(pca_scores_cl2, aes(x = PC1, y = PC2, color = cluster)) +
  geom_point(size = 3) +
  theme_minimal() +
  geom_text(aes(label = region), vjust = -0.5, hjust = 0.5)+
  labs(title = "PCA with Cluster Assignments",
       x = "PC1", y = "PC2", color = "Cluster")

#labeling the centroids

centroids <- pca_scores_cl2 %>%
  group_by(cluster) %>%
  summarize(PC1 = mean(PC1), PC2 = mean(PC2))

#Plotting 2 clusters on PCA plot
ggplot(pca_scores_cl2, aes(x = PC1, y = PC2, color = cluster)) +
  geom_point(size = 3) +
  geom_text(data = centroids, aes(label = cluster), size = 5, color = "black") +
  theme_minimal() +
  labs(title = "PCA with Cluster Labels")
```

###II. Looking at 3 clusters
```{r}
#Creating 3 clusters
km_3 <- kmeans(pca_scores[, c("PC1", "PC2")], centers = 3)  # or 3
pca_scores$cluster <- factor(km_3$cluster)
pca_scores_c3 = pca_scores 

#Plotting 3 clusters on PCA plot
ggplot(pca_scores_c3, aes(x = PC1, y = PC2, color = cluster)) +
  geom_point(size = 3) +
  theme_minimal() +
  geom_text(aes(label = region), vjust = -0.5, hjust = 0.5)+
  labs(title = "PCA with Cluster Assignments",
       x = "PC1", y = "PC2", color = "Cluster")

#labeling the centroids
centroids <- pca_scores_c3 %>%
  group_by(cluster) %>%
  summarize(PC1 = mean(PC1), PC2 = mean(PC2))

#Plotting 3 clusters on PCA plot with centroid labels
ggplot(pca_scores_c3, aes(x = PC1, y = PC2, color = cluster)) +
  geom_point(size = 3) +
  geom_text(data = centroids, aes(label = cluster), size = 5, color = "black") +
  theme_minimal() +
  labs(title = "PCA with Cluster Labels")

```

#8.Visualizing the differences between clusters
##A. Subsetting genotype matrix for each cluster
```{r}
#subsetting genotype matrix by cluster
# Confirm sample alignment
all(pca_scores_cl2$sample %in% colnames(cluster_genotypes_var))  # should be TRUE
all(pca_scores_c3$sample %in% colnames(cluster_genotypes_var))

cluster_ids_2 <- unique(pca_scores_cl2$cluster)
cluster_ids_3 <- unique(pca_scores_c3$cluster)

# Create a list of genotype subsets per cluster
#for 2 clusters
cluster_genotypes_2 <- lapply(cluster_ids_2, function(cl) {
  samples_in_cluster <- pca_scores_cl2$sample[pca_scores_cl2$cluster == cl]
  cluster_genotypes_var[, samples_in_cluster, drop = FALSE]
})
names(cluster_genotypes_2) <- paste0("Cluster_", cluster_ids_2)

#head(cluster_genotypes_2)

#for 3 clusters
cluster_genotypes_3 <- lapply(cluster_ids_3, function(cl) {
  samples_in_cluster <- pca_scores_c3$sample[pca_scores_c3$cluster == cl]
  cluster_genotypes_var[, samples_in_cluster, drop = FALSE]
})
names(cluster_genotypes_3) <- paste0("Cluster_", cluster_ids_3)

#head(cluster_genotypes_3)

```

##B. Calculating # of heterozygous sites in each cluster (heterozygosity) to knwo which samples are heterozygouse vs homozygous
###I.Function to summarize genotypes
```{r}
#Function to summarize genotypes
summarize_genotypes <- function(cluster_genotypes) {
  t(apply(cluster_genotypes, 2, function(x) {
    c(
      homo_ref = sum(x == 0, na.rm = TRUE),
      het = sum(x == 1, na.rm = TRUE),
      homo_alt = sum(x == 2, na.rm = TRUE)
    )
  }))
}

# Apply to each cluster
sample_summaries_c2 <- lapply(cluster_genotypes_2, summarize_genotypes)
sample_summaries_c3 <- lapply(cluster_genotypes_3, summarize_genotypes)

```

###II. Adding cluster info and combine
```{r}
#2 clusters
summary_df_2 <- do.call(rbind, lapply(names(sample_summaries_c2), function(cl) {
  df <- as.data.frame(sample_summaries_c2[[cl]])
  df$sample <- rownames(df)
  df$cluster <- cl
  df
}))

#3 clusters
summary_df_3 <- do.call(rbind, lapply(names(sample_summaries_c3), function(cl) {
  df <- as.data.frame(sample_summaries_c3[[cl]])
  df$sample <- rownames(df)
  df$cluster <- cl
  df
}))

```

###III. Visualizing heterozygosity between clusters
```{r}
#2 clusters
ggplot(summary_df_2, aes(x = cluster, y = het)) +
  geom_boxplot(fill = "skyblue") +
  labs(title = "Heterozygosity across clusters", y = "# Heterozygous Sites") +
  theme_minimal()

#3 clusters
ggplot(summary_df_3, aes(x = cluster, y = het)) +
  geom_boxplot(fill = "skyblue") +
  labs(title = "Heterozygosity across clusters", y = "# Heterozygous Sites") +
  theme_minimal()
```

##C. Calculating percentge of heterozygous sites
###I. 2 clusters
```{r}
#2 clusters
summary_df_2 <- summary_df_2 %>%
  mutate(
    total = homo_ref + het + homo_alt,
    perc_het = 100 * het / total,
    perc_hom_ref = 100 * homo_ref / total,
    perc_hom_alt = 100 * homo_alt / total
  )

#ggplot 
ggplot(summary_df_2, aes(x = cluster, y = perc_het)) +
  geom_boxplot(fill = "lightgreen") +
  labs(
    title = "% Heterozygosity across clusters",
    y = "% Heterozygous sites",
    x = "Cluster"
  ) +
  theme_minimal()


```

###II. 3 clusters
```{r}
#3 clusters
summary_df_3 <- summary_df_3 %>%
  mutate(
    total = homo_ref + het + homo_alt,
    perc_het = 100 * het / total,
    perc_hom_ref = 100 * homo_ref / total,
    perc_hom_alt = 100 * homo_alt / total
  )

# ggplot
ggplot(summary_df_3, aes(x = cluster, y = perc_het)) +
  geom_boxplot(fill = "lightgreen") +
  labs(
    title = "% Heterozygosity across clusters",
    y = "% Heterozygous sites",
    x = "Cluster"
  ) +
  theme_minimal()
```


##D. Calculating alternate allele frquency
###I. Mean Alt allele frequency
```{r}
#####
# Calculate mean ALT allele frequency for each sample
alt_freq <- rowMeans(t(cluster_genotypes_var) / 2, na.rm = TRUE)  # Because 2 alleles per genotype

# Add to cluster assignments
df_2 <- data.frame(population = colnames(cluster_genotypes_var),
                 cluster_no = km_2$cluster,
                 alt_freq = alt_freq)
df_3 <- data.frame(population = colnames(cluster_genotypes_var),
                 cluster_no = km_3$cluster,
                 alt_freq = alt_freq)
# Plot to compare across clusters

ggplot(df_2, aes(x = factor(cluster_no), y = alt_freq)) +
  geom_boxplot() +
  stat_summary(fun = mean, geom = "text", aes(label = round(..y.., 2)), 
               vjust = -0.5, color = "black", size = 4)+
  labs(x = "Cluster", y = "Mean ALT allele frequency") +
  theme_minimal()+
  ylim(0, 1)

ggplot(df_3, aes(x = factor(cluster_no), y = alt_freq)) +
  geom_boxplot() +
  stat_summary(fun = mean, geom = "text", aes(label = round(..y.., 2)), 
               vjust = -0.5, color = "black", size = 4)+
  labs(x = "Cluster", y = "Mean ALT allele frequency") +
  theme_minimal()+
  ylim(0, 1)
  
#compute mean per cluster and labels that


  
```

###II. Mode Alt allele frequency
```{r}
#based on mode

get_mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

mode_df_2 <- df_2 %>%
  group_by(cluster_no) %>%
  summarise(mode_alt = get_mode(round(alt_freq, 2)))  # rounding to avoid floating point noise

mode_df_3 <- df_3 %>%
  group_by(cluster_no) %>%
  summarise(mode_alt = get_mode(round(alt_freq, 2)))  # rounding to avoid floating point noise


ggplot(df_2, aes(x = factor(cluster_no), y = alt_freq)) +
  geom_boxplot() +
  geom_text(data = mode_df_2, aes(x = factor(cluster_no), y = mode_alt, label = mode_alt),
            vjust = -0.5, size = 4, color = "black") +
  labs(x = "Cluster", y = "Mean ALT allele frequency") +
  theme_minimal() +
  ylim(0, 1)


ggplot(df_3, aes(x = factor(cluster_no), y = alt_freq)) +
  geom_boxplot() +
  geom_text(data = mode_df_3, aes(x = factor(cluster_no), y = mode_alt, label = mode_alt),
            vjust = -0.5, size = 4, color = "black") +
  labs(x = "Cluster", y = "Mean ALT allele frequency") +
  theme_minimal() +
  ylim(0, 1)

```


###III. Distribution of allel frequency
```{r}
#2 cluster
ggplot(df_2, aes(x = alt_freq)) +
  geom_histogram(binwidth = 0.05, fill = "steelblue") +
  labs(x = "Mean ALT allele frequency", y = "Number of samples") +
  theme_minimal()

#3 cluster
ggplot(df_3, aes(x = alt_freq)) +
  geom_histogram(binwidth = 0.05, fill = "steelblue") +
  labs(x = "Mean ALT allele frequency", y = "Number of samples") +
  theme_minimal()
```

#9. Visualizing differences across populations/samples
##A. 2 Clusters
FOR CHROMOSOME17, T-HAPLOTYPE, THIS SHOWS EXACT POPULATION RESUTLS FROM KENNEDY'S T-HAPLOTYPE ANALYSIS
```{r}
# Melt the % data
summary_long_2 <- summary_df_2 %>%
  select(sample, cluster, perc_hom_ref, perc_het, perc_hom_alt) %>%
  pivot_longer(
    cols = starts_with("perc_"),
    names_to = "genotype",
    values_to = "percent"
  )

summary_long_2$genotype <- factor(summary_long_2$genotype, levels = c("perc_hom_ref", "perc_hom_alt", "perc_het"))


ggplot(summary_long_2, aes(x = sample, y = percent, fill = genotype)) +
  geom_bar(stat = "identity") +
  facet_wrap(~cluster, scales = "free_x") +
  labs(title = "Genotype composition per sample", y = "% of SNPs", x = "Sample") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))


```

##B. 3 clusters
```{r}
# Melt the % data
summary_long_3 <- summary_df_3 %>%
  select(sample, cluster, perc_hom_ref, perc_het, perc_hom_alt) %>%
  pivot_longer(
    cols = starts_with("perc_"),
    names_to = "genotype",
    values_to = "percent"
  )

summary_long_3$genotype <- factor(summary_long_3$genotype, levels = c("perc_hom_ref", "perc_hom_alt", "perc_het"))


ggplot(summary_long_3, aes(x = sample, y = percent, fill = genotype)) +
  geom_bar(stat = "identity") +
  facet_wrap(~cluster, scales = "free_x") +
  labs(title = "Genotype composition per sample", y = "% of SNPs", x = "Sample") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
```

##C. Allele freqeuncy distribution 
###I. 2 clusters
```{r}
# 2 cluster

#histogram
ggplot(df_2, aes(x = alt_freq, fill = population)) +
  geom_histogram(binwidth = 0.05, position = "dodge") +
  labs(x = "Mean ALT allele frequency", y = "Number of samples") +
  theme_minimal()

#scatterplot
ggplot(df_2, aes(x = factor(cluster_no), y = alt_freq, colour = population)) +
  geom_jitter(width = 0.2, height = 0, size = 2, alpha = 0.7) +
  labs(x = "Cluster number", y = "Mean ALT allele frequency") +
  theme_minimal()

```

###II. 3 clusters
```{r}
# 3 cluster
ggplot(df_3, aes(x = alt_freq, fill = population)) +
  geom_histogram(binwidth = 0.05, position = "dodge") +
  labs(x = "Mean ALT allele frequency", y = "Number of samples") +
  theme_minimal()

ggplot(df_3, aes(x = factor(cluster_no), y = alt_freq, colour = population)) +
  geom_jitter(width = 0.2, height = 0, size = 2, alpha = 0.7) +
  labs(x = "Cluster number", y = "Mean ALT allele frequency") +
  theme_minimal()
```

